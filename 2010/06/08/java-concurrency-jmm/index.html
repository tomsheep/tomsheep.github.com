
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Java Concurrency(1) - 言之有误</title>
    
    <meta name="author" content="tomsheep">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="wumiiVerification" content="56c9ca2d-c422-4b6a-8471-1de5dc5088af" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="/assets/themes/twitter/js/jquery.min.js"></script>

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/pygments.css" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="/">言之有误</a>
          <ul class="nav">
            <li><a href="/">首页</a></li>
            
            
            


  
    
      
    
  
    
      
      	
      	<li><a href="/about.html">关于</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/archive.html">归档</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">分类</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  




            <li><a href="/rss.xml">RSS</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        
<div class="page-header">
  <h1>Java Concurrency(1) <small>Java内存模型</small></h1>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="date">
      <span>2010-06-08</strong>
    </div>
    <div class="content">
      <p>JMM即Java Memory Model，设想有这样一条赋值语句：<code>int a = 1;</code> 而a为诸多线程所共享， JMM所关注的问题就是：“读取a的线程在何时会看到值为1的这个写入？”</p>

<h2>为什么关注JMM？</h2>

<p>在多数情况下，即使是并发程序的程序员，也并不特别关心JMM，因为Java语言与JVM用更高抽象的“同步”语义隐藏了JMM的语义，使得程序员即便对JMM一无所知，也可以写出优雅的并发程序。许多介绍Java同步机制的资料也并不对JMM做过多的介绍。那么你可能会问，“那一上来就讨论JMM有毛用啊？”相信我，是有毛用的。虽然我对Java并不是十分精通，Java下的并发编程更是新上手的菜鸟，但近一段时间的学习经验告诉我，所谓同步，无非关注于两点，一是互斥性，二是可见性。结合自己过去的认识，对并发的理解过多侧重于“互斥性”，而对“可见性”一知半解，影响了对同步更精细的理解。JMM则对此有十分清晰的阐述。</p>

<h2>JMM从何而来？</h2>

<p>这就要从盘古开天辟地开始说起了……话说冯诺依曼童鞋当年提出经典的体系结构时，打死他想不到现代的计算机体系结构会发展到这个鸟样子。冯诺依曼模型是一个顺序化的计算模型，可见性不是什么问题，而今天的多处理器架构已经很少再使用顺序一致化模型，而且处理器和编译器的一些优化都会对内存的可见性产生影响：</p>

<ol>
<li>处理器乱序执行</li>
<li>存储在处理器本地的缓存，对其他处理器不可见</li>
<li>作为优化，编译器可能把变量存在寄存器而非内存</li>
<li>聪明的编译器可能改变生成指令的顺序</li>
</ol>


<p>更棘手的是，江湖之大，各门各派对这些行为并没有达成统一的共识，不同架构的处理器提供了不同级别的cache coherence，而所谓一种架构的Memroy Model，即是说在该架构中，Memory的行为对应用程序做出怎样的担保。而不同架构中memory barrier这样特殊的指令，正是为了获得memory协调性而引入的。而JMM则隐藏了这些不同架构MM的差异性，千秋万载一统江湖斯密达。</p>

<h2>Happens-before关系</h2>

<p>在介绍JMM之前，我们先来了解一些比较重要的概念:</p>

<ol>
<li>如果我们把程序看成一个“动作”的集合U，在一个程序的一次执行中，所有这些动作都会在时间上（注意是时间上）有一个次序关系，我们记做“tb”(time-before)关系，显然tb是一个“全序关系”（反对称，传递，并且任意两个动作可比）</li>
<li><p>在这个“动作”集合中，有一些动作被称作“同步动作”，包括上锁/解锁，读写volitile变量，线程开始/结束等。在这个同步动作子集S上，有一个全序“sw”（synchronize-with）关系。详细的SW定义：</p>

<ul>
<li>对同一个锁，有上锁动作A，解锁动作B，如果B tb A， 则B sw A</li>
<li>对同一个volatile变量，有写动作A，读动作B，如果B tb A，则B sw A</li>
<li>对于一个线程，start动作记做A，B为任一该线程中的动作，则A sw B</li>
<li>对于一个线程，检测到线程终结的动作记做A（包括join返回，isAlive返回false等），B为任一该线程中的动作，则B sw A</li>
<li>线程t1调用线程t2的interrupt动作记做A，t2检测到中断（抛出InterruptedException，或者检测到interrupt状态更改）记做B，则 A sw B</li>
<li>对一个变量默认值赋值（0，false，null）动作记做A，对它的任意操作记做B，则A sw B</li>
<li>一个对象的构造函数结束动作记做A，该对象的finalizer开始记做B，则A sw B</li>
</ul>
</li>
</ol>


<p><strong>SW一致性含义</strong>：在全序SW中，任一个读操作读到的值是在它之前最后一个写操作写入的值。
3. 在动作集合U上，有一个偏序（自反，反对称，传递，但不是任意两个元素可比）“hb”(happens-before)关系，而他和sw关系有着千丝万缕的关系：那就是如果把sw关系从S集合拿到他的超集U中，求传递闭包，再加上“intra thread原则”——单一线程中，如果动作B在程序中出现在动作A之后，那么A hb B（这很好理解，相当于顺序模型运用在了每个线程内部）。即有：</p>

<pre><code>HB = t(SW) + IntraThread.
</code></pre>

<p>OK，现在我们已经对HB关系做出了定义。之所以要把它用离散数学的语言写出来，不单单是为了装逼，而是我深感在一些概念性的解释中，数学语言的描述是最简洁、歧义最小、最易于理解的。</p>

<p><strong>HB一致性的含义</strong>：对于一个变量，有读操作R，写操作W，如果不存在R hb W，并且也不存在另一个写操作W’，使得W hb W‘，并且W’ hb R，那么，W所写的值对于R来说，是“可能”看见的。（这好像法律条文——凡是没有禁止的，都是可能做的）</p>

<p><strong>注意1</strong>：这里需要提出的一点是，HB关系和TB关系是没有必然联系的，也就是，如果A hb B， A不一定tb B， 反过来也一样， 如果A tb B， 不一定就有 A hb B， 这是通常容易混淆的。</p>

<p><strong>注意2</strong>：从我们的定义中就可以发现，tb、sw的某些规则（前两条）、hb的某些规则（从sw演化而来的）都是依赖于某次特定的执行（execution）的，在这些情景下，脱离了这个前提，单纯的提A hb B还是C sw D都是没有意义的。</p>

<h2>JMM现身</h2>

<p>做了这么多铺垫，主角到现在还没有出现，作为导演鸭梨很大。前面已经介绍了HB关系模型，您可能认为这就是JMM了，其实是有微小差别的——JMM是一种更严格的HB模型。严格在哪里呢？<a href="http://jcp.org/jsr/detail/133.jsp" title="JSR 133 - Java Community Process Program">JSR133</a>中有一大段形式化描述，看得犯晕，即使我个人再喜欢装逼也万难再描述一遍，我用我的理解来做出简单的解释，请大牛们检查。我们看一个例子：</p>

<p>初始条件：x = y = 0</p>

<div class="highlight"><pre><code class="java">    <span class="n">Thread</span> <span class="mi">1</span><span class="o">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="c1">//A</span>
    <span class="k">if</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="c1">//B</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">//C</span>

    <span class="n">Thread</span> <span class="mi">2</span><span class="o">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>  <span class="c1">//D</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>  <span class="c1">//E</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">//F</span>
</code></pre></div>


<p>看上去有点paradox的意思，你可能认为最终a = 0， b = 0是唯一的结果。但是，在HB模型中，不是这样的。让我们来看上面这个例子：我们没有对两个线程做任何同步，对于a，b，x，y的读写都是可能存在data race的。</p>

<p><strong>插播一条data race的定义</strong>：对同一变量的两个操作A、B，如果至少有一个写操作，并且A、B不存在HB关系，则我们说两操作存在data race。</p>

<p>这里，我们把六个操作分别编号（其实6个操作可以再细分为很多个小操作，但这里不需要），我们从HB的定义中可知，同一线程中，A hb B，B hb C，D hb E， E hb F，但是，这个例子中，F和A并没有HB关系，根据HB一致性原则，那么A可以读到F的写入；同理，D可以读到C的写入——这是违背直觉的，但我们并没有违反HB的法律。所以在HB模型中，这是被允许的。</p>

<p>在JMM中，上述情景是被禁止的。而JMM是通过什么新的条文做到这一点的？我的理解是，只用了下面一条规则：</p>

<p><strong>JMM附加规则</strong>：如果某一动作的发生与否不取决于任何data race的发生与否，那么，这个动作是可以被early committed的。</p>

<p>带着这条规则，我们再来看上述例子，显然，这样一来，F不能在A之前commit，因为他依赖于对y读写data race的发生，y又依赖x，绕回来了，总之，如果不发生竞争写入，则F不可能发生。如此一来，上述情景被禁止了。为了更好理解，我们再来看一个例子：</p>

<p>初始条件：x = y = 0</p>

<div class="highlight"><pre><code class="java">    <span class="n">Thread</span> <span class="mi">1</span><span class="o">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="c1">//A</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">//B</span>

    <span class="n">Thread</span> <span class="mi">2</span><span class="o">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>  <span class="c1">//C</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">//D</span>
</code></pre></div>


<p>看上去跟刚才那个例子差不多，但如果我告诉你在这个例子中，a = 1， b =1 就是可以被JMM接受的，你会不会感到惊讶？让我们再来检查我们的规则：同样，D和A没有HB关系，B和C没有HB关系，而且，对于附加规则，B、D动作的发生不依赖与任何data race， 即是说，有没有data race，我都可以发生，那么，所有限制性规则再次全军覆没，a = 1， b = 1 可以接受。</p>

<p>最后一个例子：</p>

<p>初始条件：x = y = 0</p>

<div class="highlight"><pre><code class="java">    <span class="n">Thread</span> <span class="mi">1</span><span class="o">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>  <span class="c1">//A</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">//B</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>  <span class="c1">//C</span>

    <span class="n">Thread</span> <span class="mi">2</span><span class="o">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>  <span class="c1">//D</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>  <span class="c1">//E</span>
</code></pre></div>


<p>这个例子就没有刚才那么直观了，现在的问题是a = b = c = 1是JMM可以接受的结果吗？直觉上说，你可能脱口而出，不可能，因为违反了附加规则：操作B依赖于x的data race，x依赖y……B不能提前commit。你很聪明，但是，遗憾的是，编译器比你还聪明。我们看，在B执行的时候，a的取值可能有哪些？没错，无非是0或者1，那么，作为一个比你还聪明的编译器，看出“B操作的本质无非是b = 1，这个操作不依赖于data race发生与否”这一事实，应该是情理之中吧。那么它就会做出优化，把上述代码变为：</p>

<div class="highlight"><pre><code class="java">    <span class="n">Thread</span> <span class="mi">1</span><span class="o">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>  <span class="c1">//A</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">//B</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">//C</span>

    <span class="n">Thread</span> <span class="mi">2</span><span class="o">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>  <span class="c1">//D</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>  <span class="c1">//E</span>
</code></pre></div>


<p>现在，你还说他违反附加原则吗？因此这个情景是被JMM接受的。</p>

<h2>总结</h2>

<p>上述是我对JMM一点皮毛的理解，主要参考资料：</p>

<ul>
<li><a href="http://jcp.org/jsr/detail/133.jsp" title="JSR 133 - Java Community Process Program">JSR133</a></li>
<li>Addison Wesley, <em>Java Concurrency in Practice</em> ,Brian Goetz</li>
<li>各路网文</li>
</ul>


    </div>
    <script type="text/javascript" id="wumiiRelatedItems"></script>

  


  <!-- Baidu Button BEGIN -->
<div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare">
<a class="bds_douban"></a>
<a class="bds_tsina"></a>
<a class="bds_tqq"></a>
<a class="bds_renren"></a>
<a class="bds_fbook"></a>
<a class="bds_twi"></a>
<span class="bds_more"></span>
</div>
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6656971" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
var bds_config={"snsKey":{'tsina':'','tqq':'','t163':'','tsohu':''}}
document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<div class="clearfix"></div>
<!-- Baidu Button END -->





  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
     
    	<li><a href="/categories.html#天工开物-ref">
    		天工开物 <span>8</span>
    	</a></li>
    
  


    </ul>
    

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
     
    	<li><a href="/tags.html#Java-ref">Java <span>6</span></a></li>
     
    	<li><a href="/tags.html#多线程-ref">多线程 <span>4</span></a></li>
     
    	<li><a href="/tags.html#内存模型-ref">内存模型 <span>1</span></a></li>
    
  



    </ul>
    

    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="/2010/06/03/people_beat_us" title="不是人民怕美帝">&larr; 上一篇</a></li>
      
      <li><a href="/">回首页</a></li>
      
        <li class="next"><a href="/2010/06/09/java-concurrency-monitor" title="Java Concurrency(2)">下一篇 &rarr;</a></li>
      
      </ul>
    </div>
    <hr>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'tomsheepblog'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </div>
</div>
<script type="text/javascript">
    var wumiiPermaLink = location.href; //请用代码生成文章永久的链接
    var wumiiTitle = $('.page-header').text().trim(); //请用代码生成文章标题
    var wumiiTags = $('.icon-tags').parent().siblings().find('a').clone().children().remove().end().text().trim().split(' ').join(','); //请用代码生成文章标签，以英文逗号分隔，如："标签1,标签2"
    var wumiiCategories = $('.icon-folder-open').parent().siblings().find('a').clone().children().remove().end().text().trim().split(' '); //请用代码生成文章分类，分类名放在 JSONArray 中，如: ["分类1", "分类2"]
    var wumiiSitePrefix = "http://blog.tomsheep.net/";
    var wumiiParams = "&num=5&mode=3&pf=JAVASCRIPT";
</script>
<script type="text/javascript" src="http://widget.wumii.cn/ext/relatedItemsWidget"></script>
<a href="http://www.wumii.com/widget/relatedItems" style="border:0;">
    <img src="http://static.wumii.cn/images/pixel.png" alt="无觅关联推荐，快速提升流量" style="border:0;padding:0;margin:0;" />
</a>


      </div>
      <hr>
      <footer>
      <p>&copy; 2014 <a href="/about.html">tomsheep</a>
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div>

    <script type="text/javascript">
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}

$(document).bind('DOMNodeInserted', function(event) {
  addBlankTargetForLinks();
});
</script>

    


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-16543336-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




  </body>
</html>

