---
layout: post
category : 儒林外史
title: 屌丝的自我修养（83）
date: 2012-08-16 23:11:05 +08:00
tagline:
tags: [豆瓣, 电台, 音乐, Unix, APUE, 进程, daemon, fork]
---


1. 据说对于80%的中国用户，电台产品只要分“流行音乐”和“其他”两个频道就可以了——这次我终于不是一小撮了。

2. 有没有人离职我不太清楚，不过现在只要我的豆瓣广播里出现大规模的关注刷屏，肯定是有人入职了。

3. 毕业时为了搬家方便，把大学里几乎所有的书都送人了，今天想翻一下APUE，真想挠墙。

4. Unix中创建一个daemon进程为什么需要fork两次？就像这样：

        void do_fork() {
            int pid = fork();
            if(pid > 0)
                exit(0);
            else if(pid < 0)
                exit(1);
        }

        void init_daemon(void) {
            do_fork();
            setsid();
            do_fork();
            chdir("/");
            umask(0);
            return;
        }

    整个流程解释如下：

    * *do_fork*做的事情是: 复制一个子进程，然后杀死父进程。第一个*do_fork*有两重作用，一是为后面的setsid做准备，因为setsid调用者必须不是一个进程组的首进程；二是，如果daemon进程是由一条shell命令启动的，那么父进程终止使得shell认为这条命令已经完成。

    * setsid的作用是建立新的会话(session)。用户登录是一个会话的开始。登录之后，用户会得到一个跟用户使用的终端相连的进程，这个进程被称作是这个会话的leader，会话的id就等于该进程的pid。会话结束，并不意味着在该会话中创建的所有进程都结束了。所谓的daemon进程，正是在某个会话中创建，但是却不依赖该会话，而常驻后台的进程。 

    * 一个会话只能有一个控制终端, 产生在控制终端上的输入和信号将发送给会话的前台进程组中的所有进程终端上的连接断开时 (比如网络断开或 Modem 断开), 挂起信号(SIGHUP)将发送到控制进程(session leader)。会话的leader进程很可能是一个shell，它在收到SIGHUP信号后，并不是马上退出，而是会向它所启动的子进程都各自发送一个SIGHUP信号，将它们都杀死，然后自己才退出。不过，如果是这个作为leader进程shell自己退出，而导致终端hangup的话，向其子进程发送SIGHUP信号的事情就不会发生了。

    * setsid后子进程（这时候父进程已死）成为新会话的领头进程，而为什么要再*do_fork*一次呢？这是为了禁止进程重新打开控制终端。因为会话的领头进程打开一个终端之后, 该终端就成为该会话的控制终端，这不是我们想看到的，我们的目的是创建一个daemon进程。这时*do_fork*后，产生孙子进程，而子进程死掉，这时孙子进程就不是会话领头进程了。

    * chdir是在干什么？ 进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录（或者其他目录，用来做一些自己的事情，比如/tmp之类）

    * umask(0)将文件创建mask清掉。因为由继承得来的文件方式创建屏蔽字可能会拒绝设置某些许可权。例如，若精灵进程要创建一个组可读、写的文件，而继承的文件方式创建屏蔽字，屏蔽了这两种许可权，则所要求的组可读、写就不能起作用。

    * 一般情况下，还会再关掉不需要的继承来的文件描述符（上面的程序没有体现，关哪些描述符和具体的daemon进程有关）。

    * 参考APUE、文章 [setsid()][1] 和 [python how to write a daemon][2]
     
[1]: http://blog.csdn.net/tdonald/article/details/1724996 "setsid()"
[2]: http://chowroc.blogspot.com/2007_05_01_archive.html "python how to write a daemon"
